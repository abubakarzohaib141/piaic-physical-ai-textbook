"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3327],{5680:(e,n,a)=>{a.d(n,{xA:()=>g,yg:()=>m});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach(function(n){i(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),c=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},g=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef(function(e,n){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),u=c(a),d=i,m=u["".concat(s,".").concat(d)]||u[d]||p[d]||o;return a?t.createElement(m,r(r({ref:n},g),{},{components:a})):t.createElement(m,r({ref:n},g))});function m(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8060:(e,n,a)=>{a.r(n),a.d(n,{contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var t=a(8168),i=(a(6540),a(5680));const o={},r="Module 2: The Digital Twin - Gazebo Simulation",l={unversionedId:"physical-ai/module2-gazebo/overview",id:"physical-ai/module2-gazebo/overview",isDocsHomePage:!1,title:"Module 2: The Digital Twin - Gazebo Simulation",description:"Overview",source:"@site/docs/physical-ai/module2-gazebo/overview.md",sourceDirName:"physical-ai/module2-gazebo",slug:"/physical-ai/module2-gazebo/overview",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module2-gazebo/overview",editUrl:"https://github.com/abubakarzohaib141/piaic-physical-ai-textbook/edit/main/docs/docs/physical-ai/module2-gazebo/overview.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"URDF - Unified Robot Description Format",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module1-ros2/urdf"},next:{title:"Gazebo Sensors - Simulating Robot Perception",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module2-gazebo/sensors"}},s=[{value:"Overview",id:"overview",children:[]},{value:"What is a Digital Twin?",id:"what-is-a-digital-twin",children:[]},{value:"Why Simulation Matters for Humanoid Robots",id:"why-simulation-matters-for-humanoid-robots",children:[]},{value:"Gazebo Architecture",id:"gazebo-architecture",children:[]},{value:"Installing Gazebo with ROS 2",id:"installing-gazebo-with-ros-2",children:[]},{value:"Creating Your First World",id:"creating-your-first-world",children:[]},{value:"Spawning a Humanoid Robot",id:"spawning-a-humanoid-robot",children:[{value:"1. Create Gazebo Launch File",id:"1-create-gazebo-launch-file",children:[]}]},{value:"Physics Simulation",id:"physics-simulation",children:[{value:"Gravity and Forces",id:"gravity-and-forces",children:[]},{value:"Contact and Friction",id:"contact-and-friction",children:[]}]},{value:"Adding Control to Your Robot",id:"adding-control-to-your-robot",children:[{value:"ros2_control Integration",id:"ros2_control-integration",children:[]},{value:"Position Controller",id:"position-controller",children:[]}]},{value:"Advanced Features",id:"advanced-features",children:[{value:"Plugin System",id:"plugin-system",children:[]},{value:"ROS 2 Gazebo Bridge",id:"ros-2-gazebo-bridge",children:[]}]},{value:"Environment Building",id:"environment-building",children:[{value:"Adding Objects",id:"adding-objects",children:[]},{value:"Model Database",id:"model-database",children:[]}]},{value:"Unity Alternative",id:"unity-alternative",children:[{value:"Unity Robotics Hub",id:"unity-robotics-hub",children:[]}]},{value:"Performance Optimization",id:"performance-optimization",children:[]},{value:"Debugging Tools",id:"debugging-tools",children:[]},{value:"Next Steps",id:"next-steps",children:[]},{value:"Resources",id:"resources",children:[]}],c={toc:s},g="wrapper";function u({components:e,...n}){return(0,i.yg)(g,(0,t.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"module-2-the-digital-twin---gazebo-simulation"},"Module 2: The Digital Twin - Gazebo Simulation"),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,"Before deploying code to expensive hardware, we test in ",(0,i.yg)("strong",{parentName:"p"},"simulation"),". Gazebo is the industry-standard physics simulator for robotics that provides:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Realistic Physics"),": Gravity, friction, collisions, inertia"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Sensor Simulation"),": Cameras, LiDAR, IMU, force/torque sensors"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"ROS 2 Integration"),": Seamless communication with ROS 2 nodes"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Environment Building"),": Create custom worlds for testing")),(0,i.yg)("h2",{id:"what-is-a-digital-twin"},"What is a Digital Twin?"),(0,i.yg)("p",null,"A ",(0,i.yg)("strong",{parentName:"p"},"digital twin")," is a virtual representation of a physical robot that:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"\u2705 Behaves identically to the real robot within simulation constraints"),(0,i.yg)("li",{parentName:"ul"},"\u2705 Uses the exact same control code as the real robot"),(0,i.yg)("li",{parentName:"ul"},"\u2705 Provides a safe environment for testing dangerous scenarios"),(0,i.yg)("li",{parentName:"ul"},"\u2705 Enables rapid iteration without hardware damage")),(0,i.yg)("h2",{id:"why-simulation-matters-for-humanoid-robots"},"Why Simulation Matters for Humanoid Robots"),(0,i.yg)("p",null,"Humanoid robots are:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Expensive")," ($10k - $100k+)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Fragile")," when testing unknown behaviors"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Slow to iterate")," on physical hardware"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Dangerous")," if control algorithms fail")),(0,i.yg)("p",null,"Simulation allows us to:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Test thousands of scenarios overnight"),(0,i.yg)("li",{parentName:"ul"},"Train reinforcement learning agents safely"),(0,i.yg)("li",{parentName:"ul"},"Debug perception and planning algorithms"),(0,i.yg)("li",{parentName:"ul"},"Develop without physical hardware access")),(0,i.yg)("h2",{id:"gazebo-architecture"},"Gazebo Architecture"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-mermaid"},"graph TD\n    A[Gazebo Server] --\x3e B[Physics Engine]\n    A --\x3e C[Sensor Manager]\n    A --\x3e D[Rendering Engine]\n    E[ROS 2 Nodes] <--\x3e|Topics/Services| A\n    F[URDF Model] --\x3e A\n    G[World SDF] --\x3e A\n")),(0,i.yg)("h2",{id:"installing-gazebo-with-ros-2"},"Installing Gazebo with ROS 2"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Install Gazebo Harmonic (latest)\nsudo apt install ros-humble-gazebo-ros-pkgs\n\n# Install additional tools\nsudo apt install ros-humble-gazebo-ros2-control\nsudo apt install ros-humble-ros-gz-bridge\n\n# Test installation\ngz sim\n")),(0,i.yg)("h2",{id:"creating-your-first-world"},"Creating Your First World"),(0,i.yg)("p",null,"Create a simple world file (",(0,i.yg)("inlineCode",{parentName:"p"},"empty_world.sdf"),"):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0"?>\n<sdf version="1.9">\n  <world name="empty_world">\n    \n    \x3c!-- Physics settings --\x3e\n    <physics name="1ms" type="ignored">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n    \n    \x3c!-- Lighting --\x3e\n    <light type="directional" name="sun">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n      </attenuation>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n    \n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n    \n  </world>\n</sdf>\n')),(0,i.yg)("p",null,"Launch it with:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"gz sim empty_world.sdf\n")),(0,i.yg)("h2",{id:"spawning-a-humanoid-robot"},"Spawning a Humanoid Robot"),(0,i.yg)("h3",{id:"1-create-gazebo-launch-file"},"1. Create Gazebo Launch File"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_share = get_package_share_directory('my_humanoid')\n    urdf_file = os.path.join(pkg_share, 'urdf', 'humanoid.urdf')\n    world_file = os.path.join(pkg_share, 'worlds', 'empty.world')\n    \n    return LaunchDescription([\n        # Start Gazebo\n        IncludeLaunchDescription(\n            os.path.join(\n                get_package_share_directory('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ),\n            launch_arguments={'world': world_file}.items()\n        ),\n        \n        # Spawn robot\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-entity', 'humanoid',\n                '-file', urdf_file,\n                '-x', '0',\n                '-y', '0',\n                '-z', '1.0'\n            ],\n            output='screen'\n        ),\n        \n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            parameters=[{'robot_description': open(urdf_file).read()}]\n        ),\n    ])\n")),(0,i.yg)("h2",{id:"physics-simulation"},"Physics Simulation"),(0,i.yg)("h3",{id:"gravity-and-forces"},"Gravity and Forces"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'\x3c!-- In your SDF world file --\x3e\n<physics name="default_physics">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <gravity>0 0 -9.81</gravity>  \x3c!-- Earth gravity --\x3e\n</physics>\n')),(0,i.yg)("h3",{id:"contact-and-friction"},"Contact and Friction"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<gazebo reference="foot_link">\n  <mu1>0.8</mu1>  \x3c!-- Friction coefficient direction 1 --\x3e\n  <mu2>0.8</mu2>  \x3c!-- Friction coefficient direction 2 --\x3e\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n  <kd>100.0</kd>  \x3c!-- Contact damping --\x3e\n  <minDepth>0.001</minDepth>\n  <maxVel>0.1</maxVel>\n  <material>Gazebo/Grey</material>\n</gazebo>\n')),(0,i.yg)("h2",{id:"adding-control-to-your-robot"},"Adding Control to Your Robot"),(0,i.yg)("h3",{id:"ros2_control-integration"},"ros2_control Integration"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<ros2_control name="GazeboSystem" type="system">\n  <hardware>\n    <plugin>gazebo_ros2_control/GazeboSystem</plugin>\n  </hardware>\n  \n  <joint name="left_knee">\n    <command_interface name="position">\n      <param name="min">0</param>\n      <param name="max">2.356</param>\n    </command_interface>\n    <state_interface name="position"/>\n    <state_interface name="velocity"/>\n    <state_interface name="effort"/>\n  </joint>\n  \n  \x3c!-- Repeat for other joints --\x3e\n</ros2_control>\n')),(0,i.yg)("h3",{id:"position-controller"},"Position Controller"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},"# config/controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100\n    \n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n      \n    position_controller:\n      type: position_controllers/JointGroupPositionController\n      \nposition_controller:\n  ros__parameters:\n    joints:\n      - left_shoulder\n      - left_elbow\n      - right_shoulder\n      - right_elbow\n      - left_hip\n      - left_knee\n      - right_hip\n      - right_knee\n")),(0,i.yg)("h2",{id:"advanced-features"},"Advanced Features"),(0,i.yg)("h3",{id:"plugin-system"},"Plugin System"),(0,i.yg)("p",null,"Gazebo uses plugins to extend functionality:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},"// Custom sensor plugin example\nclass MyCustomSensor : public gazebo::SensorPlugin {\npublic:\n  void Load(gazebo::sensors::SensorPtr _sensor, sdf::ElementPtr _sdf) {\n    // Initialize sensor\n  }\n  \n  void OnUpdate() {\n    // Process sensor data\n    // Publish to ROS 2\n  }\n};\n")),(0,i.yg)("h3",{id:"ros-2-gazebo-bridge"},"ROS 2 Gazebo Bridge"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"# Bridge Gazebo topics to ROS 2\nfrom gz_import ros2_control_demo_bringup import GazeboRosBridge\n\nclass GazeboBridgeNode(Node):\n    def __init__(self):\n        super().__init__('gazebo_bridge')\n        \n        # Bridge camera images\n        self.create_subscription(\n            Image,\n            '/gazebo/camera/image',\n            self.image_callback,\n            10\n        )\n")),(0,i.yg)("h2",{id:"environment-building"},"Environment Building"),(0,i.yg)("h3",{id:"adding-objects"},"Adding Objects"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},'<model name="table">\n  <static>true</static>\n  <pose>1 0 0 0 0 0</pose>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>0.8 1.2 0.8</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>0.8 1.2 0.8</size>\n        </box>\n      </geometry>\n      <material>\n        <ambient>0.5 0.3 0.1 1</ambient>\n      </material>\n    </visual>\n  </link>\n</model>\n')),(0,i.yg)("h3",{id:"model-database"},"Model Database"),(0,i.yg)("p",null,"Use pre-built models:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Access Gazebo model database\ngz model --list\n\n# Download a model\ngz model --download chair\n")),(0,i.yg)("h2",{id:"unity-alternative"},"Unity Alternative"),(0,i.yg)("p",null,"For high-fidelity visualization and human-robot interaction:"),(0,i.yg)("h3",{id:"unity-robotics-hub"},"Unity Robotics Hub"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Better graphics")," than Gazebo"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"VR/AR integration")," for telepresence"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Human animation")," mocap data"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Cross-platform")," (Windows, Mac, Linux)")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Install Unity Robotics packages\n# Follow: https://github.com/Unity-Technologies/Unity-Robotics-Hub\n")),(0,i.yg)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"[!TIP]","\n",(0,i.yg)("strong",{parentName:"p"},"Simplify Collision Meshes"),": Use primitive shapes (boxes, cylinders) instead of complex meshes for collision detection.")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"[!WARNING]","\n",(0,i.yg)("strong",{parentName:"p"},"Watch Your Physics Step Size"),": Smaller steps (0.001s) are more accurate but slower. Balance accuracy vs. speed.")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"[!IMPORTANT]","\n",(0,i.yg)("strong",{parentName:"p"},"Real-Time Factor"),": If RTF < 1.0, your simulation is running slower than real-time. Simplify your model or reduce sensor update rates.")),(0,i.yg)("h2",{id:"debugging-tools"},"Debugging Tools"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Monitor gazebo performance\ngz stats\n\n# Introspect topics\ngz topic -l\ngz topic -e -t /world/default/stats\n\n# Check model info\ngz model -m humanoid -i\n")),(0,i.yg)("h2",{id:"next-steps"},"Next Steps"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/piaic-physical-ai-textbook/docs/physical-ai/module2-gazebo/sensors"},"Sensor Simulation"))," - Add cameras, LiDAR, and IMUs"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/piaic-physical-ai-textbook/docs/physical-ai/module3-isaac/overview"},"Module 3: NVIDIA Isaac"))," - Advanced AI-powered simulation")),(0,i.yg)("h2",{id:"resources"},"Resources"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://gazebosim.org/docs"},"Gazebo Official Docs")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://docs.ros.org/en/humble/Tutorials/Advanced/Simulators/Gazebo/Gazebo.html"},"ROS 2 Gazebo Integration")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://control.ros.org/master/index.html"},"ros2_control")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/Unity-Technologies/Unity-Robotics-Hub"},"Unity Robotics Hub"))))}u.isMDXComponent=!0}}]);