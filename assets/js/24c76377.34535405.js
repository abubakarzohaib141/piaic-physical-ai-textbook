"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5244],{3097:(n,e,a)=>{a.r(e),a.d(e,{contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var t=a(8168),i=(a(6540),a(5680));const o={},r="Navigation with Nav2",l={unversionedId:"physical-ai/module3-isaac/navigation",id:"physical-ai/module3-isaac/navigation",isDocsHomePage:!1,title:"Navigation with Nav2",description:"Overview",source:"@site/docs/physical-ai/module3-isaac/navigation.md",sourceDirName:"physical-ai/module3-isaac",slug:"/physical-ai/module3-isaac/navigation",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module3-isaac/navigation",editUrl:"https://github.com/abubakarzohaib141/piaic-physical-ai-textbook/edit/main/docs/docs/physical-ai/module3-isaac/navigation.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gazebo Sensors - Simulating Robot Perception",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module2-gazebo/sensors"},next:{title:"Module 3: The AI-Robot Brain - NVIDIA Isaac",permalink:"/piaic-physical-ai-textbook/docs/physical-ai/module3-isaac/overview"}},s=[{value:"Overview",id:"overview",children:[]},{value:"Architecture",id:"architecture",children:[]},{value:"Installing Nav2",id:"installing-nav2",children:[]},{value:"Configuring Nav2 for Humanoids",id:"configuring-nav2-for-humanoids",children:[{value:"1. Costmap Configuration",id:"1-costmap-configuration",children:[]},{value:"2. Planner Configuration",id:"2-planner-configuration",children:[]},{value:"3. Controller Configuration",id:"3-controller-configuration",children:[]}]},{value:"Implementing Bipedal Locomotion",id:"implementing-bipedal-locomotion",children:[{value:"Footstep Planner",id:"footstep-planner",children:[]},{value:"Balance Controller",id:"balance-controller",children:[]}]},{value:"Using Isaac ROS for VSLAM",id:"using-isaac-ros-for-vslam",children:[]},{value:"Obstacle Avoidance",id:"obstacle-avoidance",children:[]},{value:"Launch Nav2 for Humanoid",id:"launch-nav2-for-humanoid",children:[]},{value:"Testing Navigation",id:"testing-navigation",children:[]},{value:"Next Steps",id:"next-steps",children:[]},{value:"Resources",id:"resources",children:[]}],c={toc:s},p="wrapper";function m({components:n,...e}){return(0,i.yg)(p,(0,t.A)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"navigation-with-nav2"},"Navigation with Nav2"),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Nav2")," (Navigation 2) is the ROS 2 navigation stack that enables autonomous mobile robot navigation. For humanoid robots, it provides:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Path Planning"),": Find collision-free paths to goals"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Costmap Generation"),": Build 2D/3D maps from sensors"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Behavior Trees"),": Complex navigation behaviors"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Recovery Behaviors"),": Handle failures gracefully")),(0,i.yg)("h2",{id:"architecture"},"Architecture"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-mermaid"},"graph TD\n    A[Goal] --\x3e B[Planner Server]\n    B --\x3e C[Controller Server]\n    D[Sensors] --\x3e E[Costmap 2D]\n    E --\x3e B\n    E --\x3e C\n    C --\x3e F[cmd_vel]\n    F --\x3e G[Robot]\n    H[Localization] --\x3e C\n    I[Behavior Server] --\x3e B\n")),(0,i.yg)("h2",{id:"installing-nav2"},"Installing Nav2"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\nsudo apt install ros-humble-turtlebot3-*  # Example configs\n")),(0,i.yg)("h2",{id:"configuring-nav2-for-humanoids"},"Configuring Nav2 for Humanoids"),(0,i.yg)("h3",{id:"1-costmap-configuration"},"1. Costmap Configuration"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},'# costmap_common.yaml\nglobal_costmap:\n  global_frame: map\n  robot_base_frame: base_link\n  update_frequency: 1.0\n  publish_frequency: 1.0\n  width: 25\n  height: 25\n  resolution: 0.05\n  \n  plugins:\n    - "static_layer"\n    - "obstacle_layer"\n    - "inflation_layer"\n    \n  static_layer:\n    plugin: "nav2_costmap_2d::StaticLayer"\n    map_subscribe_transient_local: True\n    \n  obstacle_layer:\n    plugin: "nav2_costmap_2d::ObstacleLayer"\n    enabled: True\n    observation_sources: scan\n    scan:\n      topic: /scan\n      max_obstacle_height: 2.0\n      clearing: True\n      marking: True\n      \n  inflation_layer:\n    plugin: "nav2_costmap_2d::InflationLayer"\n    cost_scaling_factor: 3.0\n    inflation_radius: 0.55  # Humanoid footprint\n\nlocal_costmap:\n  local_frame: odom\n  robot_base_frame: base_link\n  update_frequency: 5.0\n  publish_frequency: 2.0\n  width: 3\n  height: 3\n  resolution: 0.05\n  rolling_window: true\n')),(0,i.yg)("h3",{id:"2-planner-configuration"},"2. Planner Configuration"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},'# planner_server.yaml\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    planner_plugins: ["GridBased"]\n    \n    GridBased:\n      plugin: "nav2_navfn_planner/NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n')),(0,i.yg)("h3",{id:"3-controller-configuration"},"3. Controller Configuration"),(0,i.yg)("p",null,"For humanoids, use DWB (Dynamic Window Approach):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-yaml"},'# controller.yaml\ncontroller_server:\n  ros__parameters:\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    \n    FollowPath:\n      plugin: "dwb_core::DWBLocalPlanner"\n      \n      # Humanoid-specific constraints\n      min_vel_x: 0.0\n      max_vel_x: 0.3  # Slow walking\n      max_vel_y: 0.0  # No strafing (non-holonomic)\n      max_vel_theta: 0.5\n      \n      min_speed_xy: 0.0\n      max_speed_xy: 0.3\n      min_speed_theta: 0.0\n      \n      acc_lim_x: 0.25\n      acc_lim_y: 0.0\n      acc_lim_theta: 0.3\n      decel_lim_x: -0.25\n      decel_lim_y: 0.0\n      decel_lim_theta: -0.3\n      \n      vx_samples: 20\n      vy_samples: 0\n      vth_samples: 40\n      \n      # Trajectory scoring\n      critics:\n        - "RotateToGoal"\n        - "Oscillation"\n        - "BaseObstacle"\n        - "GoalAlign"\n        - "PathAlign"\n        - "PathDist"\n        - "GoalDist"\n')),(0,i.yg)("h2",{id:"implementing-bipedal-locomotion"},"Implementing Bipedal Locomotion"),(0,i.yg)("h3",{id:"footstep-planner"},"Footstep Planner"),(0,i.yg)("p",null,"For true bipedal walking:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from geometry_msgs.msg import PoseStamped\nfrom nav_msgs.msg import Path\n\nclass FootstepPlanner(Node):\n    def __init__(self):\n        super().__init__('footstep_planner')\n        \n        self.path_sub = self.create_subscription(\n            Path,\n            '/plan',\n            self.path_callback,\n            10\n        )\n        \n        self.footstep_pub = self.create_publisher(\n            FootstepArray,  # Custom message\n            '/footsteps',\n            10\n        )\n        \n    def path_callback(self, path_msg):\n        # Convert continuous path to discrete footsteps\n        footsteps = self.discretize_path(path_msg)\n        \n        # Ensure alternating feet\n        footsteps = self.alternate_feet(footsteps)\n        \n        # Check stability\n        footsteps = self.ensure_stability(footsteps)\n        \n        self.footstep_pub.publish(footsteps)\n        \n    def discretize_path(self, path):\n        # Convert path waypoints to foot placements\n        step_length = 0.3  # 30cm per step\n        footsteps = []\n        \n        for i in range(0, len(path.poses), step_length):\n            pose = path.poses[i]\n            footsteps.append(Footstep(\n                pose=pose,\n                foot='left' if i % 2 == 0 else 'right'\n            ))\n        \n        return footsteps\n")),(0,i.yg)("h3",{id:"balance-controller"},"Balance Controller"),(0,i.yg)("p",null,"Integrate with whole-body control:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"import numpy as np\nfrom scipy.spatial.transform import Rotation\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__('balance_controller')\n        \n        # Subscribe to IMU for balance\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/humanoid/imu',\n            self.imu_callback,\n            10\n        )\n        \n        # Publish joint commands\n        self.joint_pub = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory_controller/joint_trajectory',\n            10\n        )\n        \n        # PID controller for balance\n        self.pid_roll = PID(kp=2.0, ki=0.1, kd=0.5)\n        self.pid_pitch = PID(kp=2.0, ki=0.1, kd=0.5)\n        \n    def imu_callback(self, imu_msg):\n        # Get orientation\n        quat = [imu_msg.orientation.x, imu_msg.orientation.y, \n                imu_msg.orientation.z, imu_msg.orientation.w]\n        \n        r = Rotation.from_quat(quat)\n        roll, pitch, yaw = r.as_euler('xyz')\n        \n        # Calculate correction\n        ankle_roll_correction = self.pid_roll.update(roll, dt=0.01)\n        ankle_pitch_correction = self.pid_pitch.update(pitch, dt=0.01)\n        \n        # Apply to ankle joints\n        self.apply_ankle_correction(ankle_roll_correction, ankle_pitch_correction)\n")),(0,i.yg)("h2",{id:"using-isaac-ros-for-vslam"},"Using Isaac ROS for VSLAM"),(0,i.yg)("p",null,"Integrate hardware-accelerated VSLAM:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        # Isaac ROS Visual SLAM\n        Node(\n            package='isaac_ros_visual_slam',\n            executable='isaac_ros_visual_slam',\n            name='visual_slam',\n            parameters=[{\n                'enable_imu_fusion': True,\n                'publish_odom_to_base_tf': True,\n                'publish_map_to_odom_tf': True,\n            }],\n            remappings=[\n                ('visual_slam/image_0', '/humanoid/camera/left/image_raw'),\n                ('visual_slam/camera_info_0', '/humanoid/camera/left/camera_info'),\n                ('visual_slam/image_1', '/humanoid/camera/right/image_raw'),\n                ('visual_slam/camera_info_1', '/humanoid/camera/right/camera_info'),\n                ('visual_slam/imu', '/humanoid/imu'),\n            ]\n        ),\n        \n        # Nav2\n        Node(\n            package='nav2_bringup',\n            executable='bringup_launch.py',\n            name='navigation',\n            parameters=[{\n                'use_sim_time': True,\n                'autostart': True,\n            }]\n        )\n    ])\n")),(0,i.yg)("h2",{id:"obstacle-avoidance"},"Obstacle Avoidance"),(0,i.yg)("p",null,"Dynamic obstacle handling:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\n\nclass ObstacleAvoider(Node):\n    def __init__(self):\n        super().__init__('obstacle_avoider')\n        \n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10\n        )\n        \n        self.cmd_override_pub = self.create_publisher(\n            Twist,\n            '/cmd_vel_override',\n            10\n        )\n        \n    def scan_callback(self, scan_msg):\n        # Find minimum distance in front\n        front_angles = range(len(scan_msg.ranges) // 3, \n                            2 * len(scan_msg.ranges) // 3)\n        front_distances = [scan_msg.ranges[i] for i in front_angles]\n        min_dist = min(front_distances)\n        \n        # Emergency stop if too close\n        if min_dist < 0.3:\n            self.get_logger().warn(f'OBSTACLE! Distance: {min_dist:.2f}m')\n            \n            stop_cmd = Twist()\n            stop_cmd.linear.x = 0.0\n            stop_cmd.angular.z = 0.0\n            self.cmd_override_pub.publish(stop_cmd)\n")),(0,i.yg)("h2",{id:"launch-nav2-for-humanoid"},"Launch Nav2 for Humanoid"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"# nav2_humanoid_launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_dir = get_package_share_directory('humanoid_navigation')\n    \n    return LaunchDescription([\n        # Map server\n        Node(\n            package='nav2_map_server',\n            executable='map_server',\n            name='map_server',\n            parameters=[{'yaml_filename': os.path.join(pkg_dir, 'maps', 'lab.yaml')}]\n        ),\n        \n        # Localization (AMCL)\n        Node(\n            package='nav2_amcl',\n            executable='amcl',\n            name='amcl',\n            parameters=[os.path.join(pkg_dir, 'config', 'amcl.yaml')]\n        ),\n        \n        # Lifecycle manager\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager',\n            name='lifecycle_manager',\n            parameters=[{\n                'autostart': True,\n                'node_names': ['map_server', 'amcl']\n            }]\n        )\n    ])\n")),(0,i.yg)("h2",{id:"testing-navigation"},"Testing Navigation"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"# Launch Nav2\nros2 launch humanoid_navigation nav2_humanoid_launch.py\n\n# Send a goal via command line\nros2 topic pub --once /goal_pose geometry_msgs/PoseStamped \\\n  \"{header: {frame_id: 'map'}, pose: {position: {x: 2.0, y: 1.0, z: 0.0}, orientation: {w: 1.0}}}\"\n\n# Or use RViz2\nrviz2 -d $(ros2 pkg prefix humanoid_navigation)/config/nav2.rviz\n")),(0,i.yg)("p",null,'In RViz2, use "2D Goal Pose" tool to click a destination.'),(0,i.yg)("h2",{id:"next-steps"},"Next Steps"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/piaic-physical-ai-textbook/docs/physical-ai/module4-vla/overview"},"Module 4: VLA Overview"))," - NaturalLanguage commands for navigation"),(0,i.yg)("li",{parentName:"ul"},"Practice: Implement waypoint following"),(0,i.yg)("li",{parentName:"ul"},"Advanced: Multi-floor navigation with elevators")),(0,i.yg)("h2",{id:"resources"},"Resources"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://navigation.ros.org/"},"Nav2 Documentation")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://nvidia-isaac-ros.github.io/concepts/visual_slam/index.html"},"Isaac ROS Visual SLAM")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://arxiv.org/abs/2304.13653"},"Humanoid Locomotion Papers"))))}m.isMDXComponent=!0},5680:(n,e,a)=>{a.d(e,{xA:()=>p,yg:()=>_});var t=a(6540);function i(n,e,a){return e in n?Object.defineProperty(n,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):n[e]=a,n}function o(n,e){var a=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})),a.push.apply(a,t)}return a}function r(n){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?o(Object(a),!0).forEach(function(e){i(n,e,a[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach(function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(a,e))})}return n}function l(n,e){if(null==n)return{};var a,t,i=function(n,e){if(null==n)return{};var a,t,i={},o=Object.keys(n);for(t=0;t<o.length;t++)a=o[t],e.indexOf(a)>=0||(i[a]=n[a]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(t=0;t<o.length;t++)a=o[t],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(n,a)&&(i[a]=n[a])}return i}var s=t.createContext({}),c=function(n){var e=t.useContext(s),a=e;return n&&(a="function"==typeof n?n(e):r(r({},e),n)),a},p=function(n){var e=c(n.components);return t.createElement(s.Provider,{value:e},n.children)},m="mdxType",u={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},g=t.forwardRef(function(n,e){var a=n.components,i=n.mdxType,o=n.originalType,s=n.parentName,p=l(n,["components","mdxType","originalType","parentName"]),m=c(a),g=i,_=m["".concat(s,".").concat(g)]||m[g]||u[g]||o;return a?t.createElement(_,r(r({ref:e},p),{},{components:a})):t.createElement(_,r({ref:e},p))});function _(n,e){var a=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=a.length,r=new Array(o);r[0]=g;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=n,l[m]="string"==typeof n?n:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}g.displayName="MDXCreateElement"}}]);